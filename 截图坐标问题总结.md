# SimpleShot 截图坐标问题总结

## 问题描述

在 macOS 上实现区域截图时，截图位置出现严重偏移：

- **现象**：选择屏幕中央区域，实际截到的却是很小的区域，且位置完全不对
- **偏移方向**：左上到右下
- **设备**：MacBook Pro M4 (Retina 屏幕，2x 缩放)

## 根本原因

### 1. 坐标系混淆

macOS 中存在多个不同的坐标系：

| 坐标系            | 原点位置 | Y 轴方向 | 使用场景                              |
| ----------------- | -------- | -------- | ------------------------------------- |
| **AppKit 坐标系** | 左下角   | 向上 ↑   | NSEvent.mouseLocation, NSWindow.frame |
| **屏幕坐标系**    | 左上角   | 向下 ↓   | 截图、ScreenCaptureKit                |
| **NSView 坐标系** | 左下角   | 向上 ↑   | NSView 内部绘制                       |

### 2. 关键误解：Display 尺寸与缩放因子

**错误认知**：

```swift
// ❌ 错误：认为 Display.width/height 是物理像素，需要乘以 scale
let captureRect = CGRect(
    x: rect.origin.x * scale,  // 错误！
    y: rect.origin.y * scale,
    width: rect.width * scale,
    height: rect.height * scale
)
```

**正确理解**：

- `SCDisplay.width/height` 返回的是**逻辑像素**尺寸，不是物理像素
- `ScreenCaptureKit` 捕获的图片尺寸也是**逻辑像素**
- `NSScreen.backingScaleFactor` 为 2.0 只是告诉你 Retina 屏幕的缩放比例
- **逻辑坐标可以直接用于裁剪，不需要乘以缩放因子**

**实际数据验证**：

```
屏幕逻辑分辨率: 1512 x 982
Display 尺寸: 1512 x 982  (逻辑像素，非物理像素)
缩放因子: 2.0
捕获图片尺寸: 1512 x 982  (逻辑像素)

如果错误地乘以 scale 2.0:
物理坐标: 1450.6875 * 2 = 2901.375  (超出 1512 的范围！)
```

## 解决方案

### 最终正确的实现

```swift
// 1. 获取鼠标全局坐标（AppKit 坐标系，左下角原点）
let startScreen = NSEvent.mouseLocation
let currentScreen = NSEvent.mouseLocation

// 2. 计算矩形（仍在 AppKit 坐标系）
let minX = min(startScreen.x, currentScreen.x)
let minY = min(startScreen.y, currentScreen.y)
let maxX = max(startScreen.x, currentScreen.x)
let maxY = max(startScreen.y, currentScreen.y)

// 3. 找到显示空间的最大高度（用于 Y 轴翻转）
var maxScreenY: CGFloat = 0
for screen in NSScreen.screens {
    let screenMaxY = screen.frame.origin.y + screen.frame.height
    maxScreenY = max(maxScreenY, screenMaxY)
}

// 4. 转换为屏幕坐标系（左上角原点）
let screenRect = CGRect(
    x: minX,
    y: maxScreenY - maxY,  // Y 轴翻转
    width: maxX - minX,
    height: maxY - minY
)

// 5. 直接使用逻辑坐标裁剪，不乘以 scale
let captureRect = CGRect(
    x: screenRect.origin.x,      // ✅ 不乘以 scale
    y: screenRect.origin.y,      // ✅ 不乘以 scale
    width: screenRect.width,     // ✅ 不乘以 scale
    height: screenRect.height    // ✅ 不乘以 scale
)

let croppedImage = fullImage.cropping(to: captureRect)
```

## 关键要点

1. **NSEvent.mouseLocation 返回全局坐标**（左下角原点）
2. **必须翻转 Y 轴**，从 AppKit 坐标系转换为屏幕坐标系
3. **多显示器环境**需要找到整个显示空间的最大高度
4. **ScreenCaptureKit 使用逻辑像素**，不需要手动处理缩放因子
5. **避免使用窗口坐标**，直接使用全局鼠标坐标更可靠

## 其他踩过的坑

### 1. SwiftUI 手势导致卡死

- **问题**：使用 SwiftUI 的 `DragGesture` + 高窗口层级（`.screenSaver`）导致系统卡死
- **解决**：改用原生 `NSView` + `NSPanel` + `.statusBar` 层级

### 2. 窗口坐标转换复杂

- **问题**：从 NSView 坐标 → 窗口坐标 → 屏幕坐标，多次转换容易出错
- **解决**：直接使用 `NSEvent.mouseLocation` 获取全局坐标

### 3. 应用退出问题

- **问题**：截图后应用自动退出
- **解决**：
  ```swift
  NSApplication.shared.setActivationPolicy(.accessory)
  func applicationShouldTerminateAfterLastWindowClosed(_ sender: NSApplication) -> Bool {
      return false
  }
  ```

## 技术栈

- **截图框架**：ScreenCaptureKit (macOS 12.3+)
- **UI 框架**：AppKit (NSPanel + NSView)
- **快捷键**：Carbon Event Manager
- **权限**：Screen Recording Permission

## 最终效果

✅ 区域截图位置完全准确  
✅ 支持 Retina 屏幕  
✅ 多显示器兼容  
✅ 自动保存 + 剪贴板复制  
✅ 菜单栏常驻应用

---

**教训**：永远不要假设坐标系统的实现细节，要通过日志验证实际数值！
